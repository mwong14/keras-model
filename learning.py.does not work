import pandas as pd
import numpy as np
import os,json

def main():
    with open('vocab.json', 'r') as f:
        index = f
    vectors = np.load('vectors.npy')
    target_output = vectors
    input_layer = len(vectors[0])
    hidden_layer = len(vectors[0])
    output_layer = 1
    if os.path.exists('weight_hidden_layer.npy'):
        weight_hidden_layer = np.load('weight_hidden_layer.npy')
    else:
        weight_hidden_layer = np.random.uniform(-1, 1, (input_layer, hidden_layer))
    
    if os.path.exists('weight_output_layer.npy'):
        weight_output_layer = np.load('weight_output_layer.npy')
    else:
        weight_output_layer = np.random.uniform(-1, 1, (hidden_layer, output_layer))
    
    if os.path.exists('bias_hidden.npy'):
        bias_hidden = np.load('bias_hidden.npy')
    else:    
        bias_hidden = np.random.uniform(-1, 1, (1, hidden_layer))
    
    if os.path.exists('output_bias.npy'):
        output_bias = np.load('output_bias.npy')
    else:
        output_bias = np.random.uniform(-1, 1, (1, output_layer))

    for epoch in range(10):
        hidden_layer_input = np.dot(vectors, weight_hidden_layer) + bias_hidden
        hidden_layer_output = sigmoid_function(hidden_layer_input)

        final_layer = np.dot(hidden_layer_output, weight_output_layer) + output_bias
        predicted_output = sigmoid_function(final_layer)

        loss = np.mean((target_output - predicted_output) ** 2)
        
        error = target_output - predicted_output
        d_predicted_output = (error * sigmoid_derivative(predicted_output))

        error_hidden_layer = d_predicted_output.dot(weight_output_layer)
        d_hidden_layer = error_hidden_layer * sigmoid_derivative(hidden_layer_output)
        print(weight_output_layer)
        print(hidden_layer_output.T)
        print(d_predicted_output)
        
        weight_output_layer += (hidden_layer_output * d_predicted_output) * 0.02
        weight_hidden_layer += vectors.T.dot(d_hidden_layer) * 0.02
        bias_hidden += np.sum(d_hidden_layer, axis=0, keepdims=True) * 0.02
        output_bias += np.sum(d_predicted_output, keepdims=True) * 0.02

        if epoch >= 979:
            print(f'Epoch : {epoch}, Loss: {loss}, Predictions: {predicted_output}')
    
    np.save('weight_hidden_layer.npy', weight_hidden_layer)
    np.save('weight_output_layer.npy', weight_output_layer)
    np.save('bias_hidden.npy', bias_hidden)
    np.save('output_bias.npy', output_bias)

def sigmoid_function(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
    return x * (1 - x)

if __name__ == '__main__':
    main()